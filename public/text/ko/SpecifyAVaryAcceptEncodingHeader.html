<br>
	유저가 지원하지 않는 압축 방식을 명시하는 오류를 범하지 않기 위해, Accept-Encoding header 에 압축 전과 후의 모든 버전을 명시해줍니다.<br>
<br>


네트워크를 통해 HTTP 요청과 응답을 전송하는데 걸리는 시간은 초반 로딩을 설계하는 엔지니어의 결정에 의해 크게 줄일 수 있다. 고객의 대역폭 속도, ISP(Internet service provider), peering 교환(ISP간의 트래픽 교환 방식) 지점과의 접근성 등은 개발팀의 통제를 벗어난 요소들이다. 하지만 응답시간에 영향을 주는 다른 변수들이 있다. 그 중 하나인 압축은 HTTP 응답의 크기를 줄임으로써 응답시간을 줄일 수 있는 하나의 방법이다.<br><br>
HTTP/1.1로 시작하는 웹클라이언트는 HTTP 요청에서 Accept-Encoding header를 가진 압축지원을 나타낸다.
Accept-Encoding: gzip, deflate
만약 웹서버가 요청에서 이 header를 본다면, 고객에 의해 작성된 방법 중 하나를 사용하여 응답을 압축할 수 있을지도 모른다. 웹서버는 요청에서 Content-Encoding header를 통해 웹클라이언트에게 알려준다.
Content-Encoding: gzip<br><br>
Gzip은 현재 가장 대중적이고 효과적인 압축방법이다. 이것은 GNU 프로젝트와 RFC 1952에 의해 표준화된 개발법이며 유일한 다른 압축형식은 deflate이지만, 이것은 덜 대중적이고 효과적이지 못하다.
일반적으로 gzipping은 약 70%까지의 응답크기를 줄일 수 있다. 오늘날 인터넷 트래픽의 약 90%는 gzip을 지원하는 browsers를 통해 이동되며 만약 Apache를 사용한다면 gzip에 설정된 module은 서버의 버전에 따라 결정되기도 한다. 예를 들어 Apache 2.x는 mod_deflate를 사용하지만 Apache 1.3은 mod_gzip을 사용한다.
browsers와 proxies에 관해 알려진 몇 가지 문제점은 browser가 예상한 것과 압축된 content와 관련해 받은 무언가에서 불일치를 야기할 수도 있다는 것이다. 다행히도 이런 문제는 오래된 browsers 사용이 감소함에 따라 줄어들고 있다. 또한 Apache modules은 적절하고 다양하게 응답하는 headers들을 자동적으로 추가해서 도움이 될 수 있다.<br><br>
서버는 파일유형에 따라 압축대상을 선택할 수 있지만 일반적으로 이 결정에는 많은 제약이 따른다. 대부분의 웹사이트들은 자신들의 HTML 문서를 압축한다. 그 압축툴은 scripts와 stylesheets를 압축하는 데에도 매우 유용한 것들이지만 많은 웹사이트들은 이 기회를 놓치고 있다. 이미지와 PDF 파일은 이미 압축이 되어있기 때문에 압축할 필요가 없지만 XML이나 JSON을 포함한 텍스트 응답을 압축하는 데에는 유용하다. CPU를 낭비할 뿐 아니라 잠재적으로 파일크기를 증가시킬 수 있기 때문이다.
가능한 많은 파일 형식들을 압축하는 것은 페이지 무게를 줄이고 사용자 경험(UX)을 촉진하는 가장 쉬운 방법이다
